"""
This module contains fixtures for pytest -- objects that are set up by the test framework and summonable by name.
They can be created and torn down at different scopes: the entire test session, within a module, or around every
test function.
For more info, see here: https://docs.pytest.org/en/latest/fixture.html
"""

from typing import Iterator

import flask.testing
import pytest
import sqlalchemy.engine
import sqlalchemy.orm
from typing import IO
from unittest import mock

from app import create_app
from app.auth import service_auth
from app.db import db, model, DBSession


def _test_client() -> flask.testing.FlaskClient:
    """Builds a Flask client wired up for unit tests. Created once per test invocation and reused thereafter."""
    app = create_app()
    app.debug = True

    return app.test_client()


@pytest.fixture(scope="session")
def client() -> flask.testing.FlaskClient:
    """A FlaskClient fixture that's created once per test run. You should use this in most instances."""
    return _test_client()


@pytest.fixture(scope="function")
def client_with_modifiable_routes() -> flask.testing.FlaskClient:
    """A FlaskClient fixture that's recreated for every test function. You'll need this if you want to dynamically add
    URL handlers in your test, otherwise previously running tests will have flipped a switch in the app that asserts
    because you've already handled a request beforehand."""
    return _test_client()


_db = None
_connection = None
Session = sqlalchemy.orm.sessionmaker()


@pytest.fixture(scope="session")
def _db_internal() -> Iterator[sqlalchemy.engine.Engine]:
    """Internal fixture for creating one sqlite db for test."""
    global _db, _connection
    _db = sqlalchemy.create_engine('sqlite://')

    # Monkeypatch over the autogenerated database with a sqlalchemy one.
    # It will get its tables recreated and dropped around every test function.
    db._db = _db

    yield _db


@pytest.fixture(scope="function", autouse=True)
def dbconnection(_db_internal: sqlalchemy.engine.Engine) -> Iterator[sqlalchemy.engine.Connection]:
    """"""
    model.Base.metadata.create_all(_db_internal)
    _connection = _db_internal.connect()

    yield _connection

    _connection.close()
    model.Base.metadata.drop_all(_db_internal)


@pytest.fixture(scope="function")
def fake_import() -> Iterator[model.Import]:
    yield model.Import("aa", "aa", "uuid", "aa@aa.aa", "gs://aa/aa", "pfb")


@pytest.fixture(scope="function")
def incoming_valid_pubsub(monkeypatch) -> Iterator[None]:
    monkeypatch.setattr(service_auth, "verify_pubsub_jwt", mock.MagicMock())
    yield


@pytest.fixture(scope="function")
def pubsub_fake_env(monkeypatch) -> Iterator[None]:
    monkeypatch.setenv("PUBSUB_PROJECT", "pubsub-project")
    monkeypatch.setenv("PUBSUB_TOPIC", "pubsub-topic")
    monkeypatch.setenv("PUBSUB_TOPIC", "pubsub-subscription")
    monkeypatch.setenv("PUBSUB_TOKEN", "token")
    monkeypatch.setenv("PUBSUB_AUDIENCE", "aud")
    monkeypatch.setenv("PUBSUB_ACCOUNT", "sa@sa.org")
    yield


@pytest.fixture(scope="function")
def fake_pfb() -> Iterator[IO]:
    with open("app/tests/empty.avro", 'rb') as out:
        yield out
